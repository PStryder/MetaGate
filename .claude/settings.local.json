{
  "permissions": {
    "allow": [
      "Bash(dir:*)",
      "Bash(cat:*)",
      "Bash(git -C \"F:/HexyLab/LV_Stack/MetaGate\" status)",
      "Bash(python -c \"\nimport pathlib\n\ncontent = ''''''\"\"\"\"\"\"Bootstrap service - core logic for bootstrap and welcome packet generation.\"\"\"\"\"\"\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, delete\nfrom datetime import datetime, timezone, timedelta\nfrom uuid import uuid4\nimport hashlib\nimport json\nfrom typing import Optional, Any\n\nfrom ..models.db_models import Principal, Binding, Profile, Manifest, StartupSession, SecretRef\nfrom ..models.schemas import WelcomePacket, StartupBlock\nfrom ..config import get_settings\n\nsettings = get_settings\\(\\)\n\n# Forbidden keys per spec section 9\nFORBIDDEN_KEYS = {\n    \"\"tasks\"\", \"\"jobs\"\", \"\"work_items\"\", \"\"payloads\"\",\n    \"\"deploy\"\", \"\"scale\"\", \"\"provision\"\", \"\"execute\"\"\n}\n\n\nclass BootstrapError\\(Exception\\):\n    \"\"\"\"\"\"Base error for bootstrap operations.\"\"\"\"\"\"\n\n    def __init__\\(self, message: str, status_code: int = 500, code: str = \"\"BOOTSTRAP_ERROR\"\"\\):\n        self.message = message\n        self.status_code = status_code\n        self.code = code\n        super\\(\\).__init__\\(message\\)\n\n\nclass ForbiddenKeyError\\(BootstrapError\\):\n    \"\"\"\"\"\"Raised when forbidden keys are detected.\"\"\"\"\"\"\n\n    def __init__\\(self, keys: set[str]\\):\n        super\\(\\).__init__\\(\n            f\"\"Forbidden keys detected: {keys}\"\",\n            status_code=400,\n            code=\"\"FORBIDDEN_KEYS\"\"\n        \\)\n\n\ndef check_forbidden_keys\\(data: dict[str, Any], path: str = \"\"\"\"\\) -> set[str]:\n    \"\"\"\"\"\"Recursively check for forbidden keys in a dict.\"\"\"\"\"\"\n    found = set\\(\\)\n    for key, value in data.items\\(\\):\n        if key.lower\\(\\) in FORBIDDEN_KEYS:\n            found.add\\(f\"\"{path}.{key}\"\" if path else key\\)\n        if isinstance\\(value, dict\\):\n            found.update\\(check_forbidden_keys\\(value, f\"\"{path}.{key}\"\" if path else key\\)\\)\n    return found\n\n\ndef generate_etag\\(data: dict[str, Any]\\) -> str:\n    \"\"\"\"\"\"Generate an ETag for the packet data.\"\"\"\"\"\"\n    content = json.dumps\\(data, sort_keys=True, default=str\\)\n    return hashlib.md5\\(content.encode\\(\\)\\).hexdigest\\(\\)\n\n\ndef generate_redacted_hash\\(data: dict[str, Any]\\) -> str:\n    \"\"\"\"\"\"Generate a redacted hash for logging \\(no secrets\\).\"\"\"\"\"\"\n    # Create a copy with sensitive fields redacted\n    safe_data = {\n        \"\"principal_key\"\": data.get\\(\"\"principal_key\"\"\\),\n        \"\"component_key\"\": data.get\\(\"\"component_key\"\"\\),\n        \"\"profile\"\": data.get\\(\"\"profile\"\"\\),\n        \"\"manifest\"\": data.get\\(\"\"manifest\"\"\\),\n        \"\"issued_at\"\": str\\(data.get\\(\"\"issued_at\"\"\\)\\),\n    }\n    content = json.dumps\\(safe_data, sort_keys=True\\)\n    return hashlib.sha256\\(content.encode\\(\\)\\).hexdigest\\(\\)[:16]\n\n\nasync def get_active_binding\\(\n    db: AsyncSession,\n    principal: Principal\n\\) -> Optional[Binding]:\n    \"\"\"\"\"\"Get the active binding for a principal.\"\"\"\"\"\"\n    result = await db.execute\\(\n        select\\(Binding\\)\n        .where\\(\n            Binding.principal_id == principal.id,\n            Binding.active.is_\\(True\\)\n        \\)\n        .limit\\(1\\)\n    \\)\n    return result.scalar_one_or_none\\(\\)\n\n\nasync def get_required_env_refs\\(\n    db: AsyncSession,\n    tenant_key: str\n\\) -> list[dict[str, Any]]:\n    \"\"\"\"\"\"Get required environment variable references.\"\"\"\"\"\"\n    result = await db.execute\\(\n        select\\(SecretRef\\).where\\(\n            SecretRef.tenant_key == tenant_key,\n            SecretRef.status == \"\"active\"\"\n        \\)\n    \\)\n    refs = result.scalars\\(\\).all\\(\\)\n\n    return [\n        {\n            \"\"secret_key\"\": ref.secret_key,\n            \"\"ref_kind\"\": ref.ref_kind,\n            \"\"ref_name\"\": ref.ref_name,\n            \"\"ref_meta\"\": ref.ref_meta\n        }\n        for ref in refs\n    ]\n\n\nasync def create_startup_session\\(\n    db: AsyncSession,\n    principal: Principal,\n    component_key: str,\n    profile: Profile,\n    manifest: Manifest,\n    packet_etag: str,\n    packet_hash_redacted: str,\n\\) -> StartupSession:\n    \"\"\"\"\"\"Create a new startup session with OPEN status.\"\"\"\"\"\"\n    now = datetime.now\\(timezone.utc\\)\n    deadline = now + timedelta\\(seconds=profile.startup_sla_seconds\\)\n\n    session = StartupSession\\(\n        id=uuid4\\(\\),\n        tenant_key=principal.tenant_key,\n        deployment_key=manifest.deployment_key,\n        subject_principal_key=principal.principal_key,\n        component_key=component_key,\n        profile_key=profile.profile_key,\n        manifest_key=manifest.manifest_key,\n        packet_etag=packet_etag,\n        packet_hash_redacted=packet_hash_redacted,\n        status=\"\"OPEN\"\",\n        opened_at=now,\n        deadline_at=deadline,\n        mirror_status=\"\"PENDING\"\",\n    \\)\n\n    db.add\\(session\\)\n    await db.commit\\(\\)\n    await db.refresh\\(session\\)\n\n    return session\n\n\nasync def cleanup_old_sessions\\(db: AsyncSession, retention_hours: int\\) -> int:\n    \"\"\"\"\"\"\n    Clean up old startup sessions past retention period.\n\n    Only removes sessions that are in terminal states \\(READY/FAILED\\).\n    Returns the number of deleted sessions.\n    \"\"\"\"\"\"\n    cutoff = datetime.now\\(timezone.utc\\) - timedelta\\(hours=retention_hours\\)\n    result = await db.execute\\(\n        delete\\(StartupSession\\).where\\(\n            StartupSession.created_at < cutoff,\n            StartupSession.status.in_\\([\"\"READY\"\", \"\"FAILED\"\"]\\)\n        \\)\n    \\)\n    await db.commit\\(\\)\n    return result.rowcount\n\n\nasync def perform_bootstrap\\(\n    db: AsyncSession,\n    principal: Principal,\n    component_key: str,\n    principal_key_hint: Optional[str],\n    last_packet_etag: Optional[str],\n\\) -> tuple[WelcomePacket, bool]:\n    \"\"\"\"\"\"\n    Perform the bootstrap operation.\n\n    Returns:\n        Tuple of \\(WelcomePacket, is_cached\\) where is_cached indicates 304 response\n    \"\"\"\"\"\"\n    # Verify principal_key hint if provided\n    if principal_key_hint and principal_key_hint != principal.principal_key:\n        raise BootstrapError\\(\n            f\"\"Principal key mismatch: hint={principal_key_hint}, actual={principal.principal_key}\"\",\n            status_code=409,\n            code=\"\"PRINCIPAL_MISMATCH\"\"\n        \\)\n\n    # Get active binding\n    binding = await get_active_binding\\(db, principal\\)\n    if not binding:\n        raise BootstrapError\\(\n            f\"\"No active binding for principal {principal.principal_key}\"\",\n            status_code=403,\n            code=\"\"NO_BINDING\"\"\n        \\)\n\n    # Load profile and manifest\n    result = await db.execute\\(select\\(Profile\\).where\\(Profile.id == binding.profile_id\\)\\)\n    profile = result.scalar_one_or_none\\(\\)\n    if not profile:\n        raise BootstrapError\\(\"\"Profile not found\"\", status_code=500, code=\"\"PROFILE_NOT_FOUND\"\"\\)\n\n    # Validate component_key is permitted by profile \\(Spec Section 3.0\\)\n    allowed_components = profile.capabilities.get\\(\"\"allowed_components\"\", []\\)\n    if allowed_components and component_key not in allowed_components:\n        raise BootstrapError\\(\n            f\"\"Component ''{component_key}'' not permitted for principal ''{principal.principal_key}''\"\",\n            status_code=403,\n            code=\"\"COMPONENT_NOT_PERMITTED\"\"\n        \\)\n\n    result = await db.execute\\(select\\(Manifest\\).where\\(Manifest.id == binding.manifest_id\\)\\)\n    manifest = result.scalar_one_or_none\\(\\)\n    if not manifest:\n        raise BootstrapError\\(\"\"Manifest not found\"\", status_code=500, code=\"\"MANIFEST_NOT_FOUND\"\"\\)\n\n    # Check for forbidden keys in manifest\n    manifest_data = {\n        \"\"environment\"\": manifest.environment,\n        \"\"services\"\": manifest.services,\n        \"\"memory_map\"\": manifest.memory_map,\n        \"\"polling\"\": manifest.polling,\n        \"\"schemas\"\": manifest.schemas,\n    }\n    forbidden = check_forbidden_keys\\(manifest_data\\)\n    if forbidden:\n        raise ForbiddenKeyError\\(forbidden\\)\n\n    # Apply overrides\n    capabilities = {**profile.capabilities}\n    policy = {**profile.policy}\n    services = {**manifest.services}\n    memory_map = {**manifest.memory_map}\n    polling = {**manifest.polling}\n    schemas = {**manifest.schemas}\n\n    if binding.overrides:\n        if \"\"capabilities\"\" in binding.overrides:\n            capabilities.update\\(binding.overrides[\"\"capabilities\"\"]\\)\n        if \"\"policy\"\" in binding.overrides:\n            policy.update\\(binding.overrides[\"\"policy\"\"]\\)\n        if \"\"services\"\" in binding.overrides:\n            services.update\\(binding.overrides[\"\"services\"\"]\\)\n        if \"\"memory_map\"\" in binding.overrides:\n            memory_map.update\\(binding.overrides[\"\"memory_map\"\"]\\)\n        if \"\"polling\"\" in binding.overrides:\n            polling.update\\(binding.overrides[\"\"polling\"\"]\\)\n        if \"\"schemas\"\" in binding.overrides:\n            schemas.update\\(binding.overrides[\"\"schemas\"\"]\\)\n\n    # Get required env refs\n    required_env = await get_required_env_refs\\(db, principal.tenant_key\\)\n\n    # Build packet data for etag\n    now = datetime.now\\(timezone.utc\\)\n    packet_id = uuid4\\(\\)\n\n    packet_data = {\n        \"\"principal_key\"\": principal.principal_key,\n        \"\"component_key\"\": component_key,\n        \"\"profile\"\": profile.profile_key,\n        \"\"manifest\"\": manifest.manifest_key,\n        \"\"capabilities\"\": capabilities,\n        \"\"policy\"\": policy,\n        \"\"services\"\": services,\n        \"\"memory_map\"\": memory_map,\n        \"\"polling\"\": polling,\n        \"\"schemas\"\": schemas,\n        \"\"required_env\"\": required_env,\n        \"\"manifest_version\"\": manifest.version,\n    }\n\n    # Generate etag\n    packet_etag = generate_etag\\(packet_data\\)\n\n    # Check for 304 Not Modified\n    if last_packet_etag and last_packet_etag == packet_etag:\n        return None, True  # Signal 304\n\n    # Create startup session\n    packet_hash_redacted = generate_redacted_hash\\({**packet_data, \"\"issued_at\"\": now}\\)\n    startup_session = await create_startup_session\\(\n        db, principal, component_key, profile, manifest,\n        packet_etag, packet_hash_redacted\n    \\)\n\n    # Build startup block\n    startup_block = StartupBlock\\(\n        startup_id=startup_session.id,\n        status=\"\"OPEN\"\",\n        deadline_at=startup_session.deadline_at,\n    \\)\n\n    # Build welcome packet\n    welcome_packet = WelcomePacket\\(\n        packet_id=packet_id,\n        packet_etag=packet_etag,\n        issued_at=now,\n        principal_key=principal.principal_key,\n        component_key=component_key,\n        profile=profile.profile_key,\n        manifest=manifest.manifest_key,\n        capabilities=capabilities,\n        policy=policy,\n        services=services,\n        memory_map=memory_map,\n        polling=polling,\n        schemas=schemas,\n        required_env=required_env,\n        startup=startup_block,\n    \\)\n\n    return welcome_packet, False\n''''''\n\npathlib.Path\\(''src/metagate/services/bootstrap.py''\\).write_text\\(content\\)\nprint\\(''File written successfully''\\)\n\")",
      "Bash(git add:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nFix critical blockers: component validation, tests, retention cleanup\n\n- Add component_key validation against profile.capabilities.allowed_components\n  \\(Spec Section 3.0\\) - returns 403 COMPONENT_NOT_PERMITTED if unauthorized\n- Add cleanup_old_sessions\\(\\) for retention policy enforcement\n- Add background retention cleanup task \\(hourly\\) in lifespan handler\n- Fix Binding.active == True to use .is_\\(True\\) for SQLAlchemy\n- Add comprehensive test suite with pytest-asyncio fixtures\n- Add aiosqlite dependency for in-memory test database\n\nðŸ¤– Generated with [Claude Code]\\(https://claude.com/claude-code\\)\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git push)"
    ]
  }
}
